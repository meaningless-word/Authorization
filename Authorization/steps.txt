1. Создаём пустой ASP.NET Core проект и копируем в него функциональность из Aothorization.Basics
2. Определим, какая информация о пользователе содержится в контексте, когда пользователь авторизован
выведем её на странице Home. для этого в HomrController.cs во вьюшке Index:
		public IActionResult Index()
		{
			ViewBag.Name = User.Identity.Name;
			ViewBag.IsAuthenticated = User.Identity.IsAuthenticated;
			return View();
		}
и в Index.cshtml
<p>
  IsAuthenticates: @ViewBag.IsAuthenticated
</p>

<p>
  Name: @ViewBag.Name
</p>
3. запускаем и видим, что статус работает, а имя не отображается
4. для доступа к имени необходимо скорректировать клаймы в методе Login
			var claims = new List<Claim>
			{
				new Claim(ClaimTypes.Name, model.UserName)
			};
при создании листа для хранения клаймов указываем, какой тип клайма хранить и чем его заполнять
5. чтобы эффективно работать с ролями, создадим два метода, в которые будет разрешен доступ для разных типов ролей
в AdminController.cs добавим новые методы, отмеченные атрибутами с именем ролей:
		[Authorize(Roles="Administrator")]
		public IActionResult Administrator()
		{
			return View();
		}

		[Authorize(Roles = "Manager")]
		public IActionResult Manager()
		{
			return View();
		}
к ним создадим соответствующие вьюшки на основе Index.cshtml
6. переходим в Startup.cs метод ConfigureServices. будем донастраивать строку srvices.AddAuthorization();
будем конфигурировать options - мы должны добавить policy
небольшое отступление...
	модель ролей возникла ещё в самом начале mvc
	ещё в asp.net page web form ролевая модель основывалась на 5-6 таблицах... и она уже себя изжила
	хотя asp.net core продолжает поддержку всех этих ролевых моделей хотя это уже легаси код 
	и куда более оптимально использовать клаймы - они более гибкие, хотя их сложнее настраивать
... отступление закончилось
policy - это один из способов управленя клаймами
добавим код
			services.AddAuthorization(options => 
			{
				options.AddPolicy("Administrator", builder =>
				{
					builder.RequireClaim(ClaimTypes.Role, "Administrator");
				});
				options.AddPolicy("Manager", builder =>
				{
					builder.RequireClaim(ClaimTypes.Role, "Manager");
				});
			});
7. прежде, чем проверить как это работает, во вьюшку Home/Index добавим ссылки
<a asp-controller="Admin" asp-action="Administrator">Administrator</a>
<a asp-controller="Admin" asp-action="Manager">Manager</a>
8. после запуска ссылки не работают, ссылаются на несуществующую страницу Access Denied
9. добавим переадресацию на несуществующую страницу:
в Startup.cs в методе ConfigureServices добавим
			services.AddAuthentication("Cookie")
				.AddCookie("Cookie", config =>
				{
					config.LoginPath = "/Admin/Login";
					config.AccessDeniedPath = "/Home/AccessDenied";
					
				});
10. теперь эту вьюшку необходимо создать
11. заодно и соответствующий метод в контроллере
12. при запуске переход по ссылкам Администратор и Менеджер приводят на страницу AccessDenied потому что пока мы не имеем информации о пользователе и его ролях
13. добавим роли. в методе Login класса AdministratorController к коллекции клаймов добавляется клайм типа "роль" с наименованием Manager:
14. запускаем. заходя на страницу Manager попадаем на страницу запроса логина\пароля. регистрируемся. и теперь легко переходим на страницу Home, Admin и Manager, 
а на страницу Administrator - Access Denied
15. поскольку в коде контроллера использовались атрибуты со словом Roles: [Authorize(Roles="Administrator")] это старый принцип. то для того, чтобы у пользователя
была возможность заходить и туда и туда, необходимо указать два клайма, чтобы определить ккие у пользователя роли:
			var claims = new List<Claim>
			{
				new Claim(ClaimTypes.Name, model.UserName),
				new Claim(ClaimTypes.Role, "Manager"),
				new Claim(ClaimTypes.Role, "Administrator")
			};
не очень гибко, так как, если в приложении будет определено 15 ролей, тогда для супер пользователя они должны быть перечислены все
и здесь на помощь приходит новый принцип авторизации на основе клаймов и полиси
16. меняем атрибуты [Authorize(Roles="Administrator")] на [Authorize(Policy="Administrator")] и соответственно для менеджера
[Authorize(Roles = "Manager")] на [Authorize(Policy = "Manager")]
и если раньше роли брались из перечня клаймов в логине
			var claims = new List<Claim>
			{
				new Claim(ClaimTypes.Name, model.UserName),
				new Claim(ClaimTypes.Role, "Manager"),
				new Claim(ClaimTypes.Role, "Administrator")
			};
то политики берутся из Startup метода ConfigureServices
			services.AddAuthorization(options => 
			{
				options.AddPolicy("Administrator", builder =>
				{
					builder.RequireClaim(ClaimTypes.Role, "Administrator");
				});
				options.AddPolicy("Manager", builder =>
				{
					builder.RequireClaim(ClaimTypes.Role, "Manager");
				});
			});
т.е. указана политика, а внутри можно указать необходимые нам роли
на примере роли менеджера:
				options.AddPolicy("Manager", builder =>
				{
					builder.RequireAssertion(x => x.User.HasClaim(ClaimTypes.Role, "Manager") || x.User.HasClaim(ClaimTypes.Role, "Administrator"))
				});
где указывается, что политике Manager доступны роли менеджера и администратора
помимо этого в выражении можно определять не только перечень ролей, но и много других дополнительных обработоа исходя из переданных данных в модели User
17. запуск показывает, что залогинившись у нас есть доступ и на страницу менеджера, и на страницу администратора
