1. Создаём пустой ASP.NET Core проект

2. в Startup.cs:
в методе Configure это
			app.UseEndpoints(endpoints =>
			{
				endpoints.MapGet("/", async context =>
				{
					await context.Response.WriteAsync("Hello World!");
				});
			});
заменить на
			app.UseEndpoints(endpoints =>
			{
				endpoints.MapDefaultControllerRoute();
			});
в методе ConfigureServices добавить
			services.AddControllersWithViews();
чтобы использовать контроллеры с вьюшками (полноценный mvc)
3. в launchSettings.json
удаляется блок IIS
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:16666",
      "sslPort": 44324
    }
  },
мз блока profiles удаляется
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
а в оставшийся блок добавляется указание на стартовый контроллер
      "launchUrl": "home/index",
4. добавить папку Controllers, а в ней создать контроллеры HomeControllers.cs и AdminController.cs
5. добавить папку Views, а в ней папки Home и Admin, в которых создать Index.cshtml
6. в файлы index добавим пока просто название страницы <h1>Home</h1> и <h1>Admin</h1> соотвветственно
7. теперь, если запустить приложение, оно стартует в браузере со страницы home по адресу https://localhost:5001/home/index, а исправив адрес на https://localhost:5001/admin/index 
отображается страница админ
8. сделаем переходы между страницами более удобныи
для этого в папку Views добавить новый элемент "Импорт представлений Razor" (_ViewImports.cshtml)
а нём добавить строку 
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
чтобы во вьюхах работать с asp-тегами
и теперь в файл Index.cshtml home-контроллера добавить сроку
<a asp-controller="Admin" asp-action="Index">Admin</a>
и аналогичную в admin-контроллер
9. проверка работоспособности... работает
10. Сейчас у нас в системе два контроллера Home и Admin, при этом доступ в админ мы хотим защитить, т.е. вход только по паролю
В asp.net core существует атрибут, который называется [Authorize]
работает он так: если его установить над классом контроллера, то тогда будут защищены все методы этого контроллера, 
а если атрибут установить над конкретным контроллером, то доступ будет закрыт только к нему
11. запустим проект и посмотрим, что произойдёт при переходе на страницу Admin
в результате получим страницу с ошибкой, где написано, что для работы нужно подключить авторизацию, утентификацию...
12. переходим к Startup.cs и в методе ConfigureServices добавляем:
			services.AddAuthentication();
			services.AddAuthorization();
перед строкой AddControllersWithViews
13. так же добавляем пару вызовов в методе Configure
			app.UseAuthentication();
			app.UseAuthorization();
главное, чтобы они размещались между роутингом и маппингом
14. запускаем снова и видим ошибку, что не указана схема аутентификации.
схем вообще несколько: одна с использованием cookies, вторая с Bearer, а можно даже свою замутить
но в данном примере будет использована схема cookies, как самая простая для этого дополним строку
			services.AddAuthentication();
в методе ConfigureServices, указав схему
			services.AddAuthentication("Cookie")
				.AddCookie("Cookie", config =>
				{
					config.LoginPath = "/Admin/Login";
				});
а заодно с ней изменить поведение по умолчанию, указав ссылку на контроллер, который должен отработать в случае неавторизованного пользователя
15. запускаем. при переходе на Admin происзодит редиерк на несуществующую пока страницу https://localhost:5001/Admin/Login?ReturnUrl=%2FAdmin
создадим её
16. в админ-контроллер добавим метод
		public IActionResult Login(string returnUrl)
		{
			return View();
		}
но, поскольку весь класс контроллера закрыт атрибутом [Authorize], доступ к методу Login закрыт ипри переходе можно попасть в рекрсию
можно, конечно, тогда ставить [Authorize] у каждого метода, но можно сделать по-другому
чтобы открыть какой-либо метод для общего доступа, необходимо над его описание поставить атрибут [AllowAnonymous]
в параметр будет передан URL перехода после ввода логина
17. далее, необходимо добавить новую вьюшку Login в папку Viewws/Admin с содержимым
<h1>Login</h1>
<a asp-controller="Home" asp-action="Index">Home</a>

<form asp-controller="Admin" asp-action="Login" method="post">
</form>

18. как видно, нам необходимо доавить ещё один метод Login с атрибутом post в контроллер
соответственно, в AdminController появится
		[HttpPost]
		[AllowAnonymous]
		public IActionResult Login(LoginViewModel model)
		{
			return View();
		}
параметром в котором служит модель, куда будут переданы учетные данные для входа с формы
19. поскольку класса модели у нас ешё нет, создадим
namespace Autorization.Basics.Models
{
	public class LoginViewModel
	{
		public string UserName { get; set; }
		public string Password { get; set; }
		public string ReturnUrl { get; set; }
	}
}
для красоты запихав в папку Models
20. а пока дорисуем, что у нас должно быть форме
первой строкой файла необходимо указать модель, в которую будут помещены данные
@model LoginViewModel
чтобы модель была видна, необходимо указать сылку на класс. делается это в файле _ViewImports.cshtml строкой
@using Autorization.Basics.Models

затем внутрь формы помещаются контролы для создания интерфейса

  <input hidden asp-for="ReturnUrl"/>

  <div>
    <label>UserName</label>
    <input asp-for="UserName"/>
  </div>
  <div>
    <label>Password</label>
    <input asp-for="Password" />
  </div>

  <p>
    <button type="submit">Login</button>
  </p>

21. поставим точку останова в методе Login, имеющем атрибут [HttpPost]
запустим.
вводим в форму произвольные данные, жмём кнопку Login и оказываемся в точке останова
обращаем внимание, что model в параметре заполнена указанными данными
22. для того, чтобы форма не срабатывала на пустых значениях, необходимо указать атрибут [Required] на кождом свойстве класса модели
а в форме поля дополнить валидаторами
    <span asp-validation-for="UserName"></span>
для имени и
    <span asp-validation-for="Password"></span>
для пароля
23. проверям - видим надпись "The UserName field is required." при попытке подсунуть пустое значение
24. теперь необходимо учинить проверку полученной модели
в методе Login, имеющем атрибут [HttpPost] проверка невалидности модели 
			if (!ModelState.IsValid)
			{
				return View(model);
			}
с возвратом её обратно во вьюшку в случае невалидности, а затем блок проверки 
			var claims = new List<Claim>
			{
				new Claim("Demo", "Value")
			};
			var claimIdentity = new ClaimsIdentity(claims, "Cookie");
			var claimPrincipal = new ClaimsPrincipal(claimIdentity);
			await HttpContext.SignInAsync("Cookie", claimPrincipal);

			return Redirect(model.ReturnUrl);
25. запуск
включим в браузере (Chromt) инструменты разработчика (Ctrl + Shift + I)
на вкладке Applications развернём структуру Storage/Cookies
переходим на страницу Login, вводим данные
и видим, как появилась новая позиция .AspNetCore.Cookie
после этого свободно можно перемещаться между страницами Home - Admin
но стоит удалить эту куку, приложение снова запросит ввести логин/пароль
26. реализуем LogOut
во вьюшке Admin добавим ссылку с выходом
<a asp-controller="Admin" asp-action="LogOff">Log Off</a>
27. добавить соответствующий метод в контроллере
		public IActionResult LogOff()
		{
			HttpContext.SignOutAsync("Cookie");
			return Redirect("/Home/Index");
		}
28. запуск
теперь, после перехода по ссылке Log Off снова запрашвается парль при входе на страницу Admin
это благодаря вызову метода HttpContext.SignOutAsync("Cookie");
